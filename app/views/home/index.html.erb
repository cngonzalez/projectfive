<%= form_tag("/display", method: "post") do %>
  <%= text_field_tag(:term1) %>
  <%= text_field_tag(:term2) %>
  <%= submit_tag("Discover") %>
<% end %>

<div class='chart'></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.15.0/lodash.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tipsy/1.0.3/jquery.tipsy.min.js"></script>

<script type="text/javascript">
var parsedRestData;

var restaurantData = $.ajax({
  type: "GET",
  url: "/assets/restaurant_average_score.csv",
  dataType: "text",
  success: function(data) { 
    parsedData = d3.csvParse(data); 
    getSecondDataSet(parsedData); 
    return data;
  }
})

function getSecondDataSet (firstDataset) {
  $.ajax({
    type: "GET",
    url: "/assets/noise_complaints.csv",
    dataType: "text",
    success: function(data) { 
      parsedData = d3.csvParse(data); 
      buildChart(firstDataset, parsedData);
      return data;
    }
  })
}

function buildChart (dataset1, dataset2) {
  //COLORS for circles and triangles
  // template from: http://codepen.io/sasidhar2992/pen/jbgbwV
  var firstColor = "#0B3B6A";
  var cowBackColor = "#D9DCDE";
  var secondColor = "#004A53";
  var oppBackColor = "whitesmoke";

  //data object to hold parsed data
  var stagingData = [];

  //parse the sample data into the data object D3 expects
  dataset1.forEach(function(entry, index) {
    // debugger;
    var tempArray = [];
    if (dataset2[index] !== undefined && entry !== undefined) {
      tempArray.push(entry.avg_score);
      tempArray.push(dataset2[index].count)
      tempArray.push(entry.zip);
      stagingData.push(tempArray);
    }
  });

  //Create object with counted occurences
  var counts = _.countBy(stagingData);
  //Sort that object's counts and reverse to get highest at 0
  var sorted = _.sortBy(counts).reverse();
  //The highest count
  var highestCount = sorted[0];

  //This is going to be the data that d3 uses after we do stuff to get it right
  var data = [];

  //Avoid duplicate entries by looping through counts instead
  //of originalData. Go through each count and get the values from the keys
  _.forOwn(counts, function(value, key) {
    var result = key.split(",");
    var tempArray = [];
    tempArray.push(parseInt(result[0]));
    tempArray.push(parseInt(result[1]));
    // console.log(tempArray);
    data.push(tempArray);
  });

  //Preview final data before D3 uses it.
  // console.log(data);
  //Dimensions
  var margin = {
    top: 10,
    right: 10,
    bottom: 50,
    left: 50
  };
  var width = 800 - margin.left - margin.right;
  var height = 600 - margin.top - margin.bottom;

  //Get and set maxValue
  var maxX = d3.max(data, function(d) {
    return d[0];
  })

  var maxY = d3.max(data, function(d) {
    return d[1];
  })

  var maxValue = 0;

  if (maxX > maxY) {
    maxValue = maxX;
  } else {
    maxValue = maxY;
  }

  //Set X range and domain
    var x = d3.scaleLinear()
      .range([0, width])
      .domain([0, maxX]);

    //Set Y range and domain
    var y = d3.scaleLinear()
      .range([height, 0])
      .domain([0, maxY]);

    //Prime axis
    var xAxis = d3.axisBottom(x).ticks(10).tickSize(-height);
    var yAxis = d3.axisLeft(y).ticks(10 * height / width).tickSize(-width);

    //Draw the shell
    var svg = d3.select(".chart").append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    //Draw triangles
    // var cowboysTrianglePoints = "0 " + height + ", " + height + " 0, " + height + " " + height;
    // var opponentTrianglePoints = "0 0, 0 " + height + ", " + height + " 0";
    //
    // svg.append('polyline')
    // .attr('points', cowboysTrianglePoints)
    // .style('fill', cowBackColor);
    //
    // svg.append('polyline')
    // .attr('points', opponentTrianglePoints)
    // .style('fill', oppBackColor);

    //Draw the axis
    svg.append("g")
      .attr("class", "x axis ")
      .attr('id', "axis--x")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis);

    svg.append("g")
      .attr("class", "y axis")
      .attr('id', "axis--y")
      .call(yAxis);

    //Draw the dots
  var r = d3.scaleLinear()
    //Range for dot sizes
    .range([5, 20])
    //Set the domain from data values
    .domain([1, highestCount]);

    svg.selectAll(".dot")
      .data(data)
      .enter().append("circle")
      .attr("class", "dot")
      .attr("r", function(d) {
	var thisCount = counts[d[0] + "," + d[1]];
	return r(parseInt(thisCount));
      })
    .attr("cx", function(d) {
      return x(parseInt(d[0]));
    })
    .attr("cy", function(d) {
      return y(parseInt(d[1]));
    })
    .attr("opacity", .5)
    .style("fill", function(d) {
      if (d[0] > d[1]) {
	return firstColor;
      } else {
	return secondColor;
      }
    });

  //Set small dots on top of big ones
  d3.selectAll("circle")
  .each(function(d) {
    var rad =  parseInt(d3.select(this).attr("r"));
    if (rad < 10) {
      this.parentElement.appendChild(this);
    }
  })

  //Draw the diagonal
  // svg.append("line")
  // .attr("x1", height)
  // .attr("y1", 0)
  // .attr("x2", 0)
  // .attr("y2", height)
  // .attr("stroke-width", 1)
  // .attr("stroke", "silver");

  var col1 = Object.keys(dataset1[0])[1]; 
  var col2 = Object.keys(dataset2[0])[1];
  //Draw the labels
  svg.append("text")
    .attr("text-anchor", "middle")
    .attr("transform", "translate(-30,300) rotate(-90)")
    .text(col1);

  svg.append("text")
    .attr("text-anchor", "middle")
    .attr("transform", "translate(300,580)")
    .text(col2);

  //Tipsy
  $('svg circle').tipsy({
    fade: true,
    gravity: 'w',
    html: true,
    title: function() {
      d = this.__data__;
      return col1 + ": " + d[0] + "<br/>" + col2 + ": " + d[1];
    }
  }); 
}
</script>
